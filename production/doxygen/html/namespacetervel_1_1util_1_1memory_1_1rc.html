<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tervel: tervel::util::memory::rc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tervel
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A collection of wait-free containers and algorithms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetervel.html">tervel</a></li><li class="navelem"><a class="el" href="namespacetervel_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacetervel_1_1util_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html">rc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tervel::util::memory::rc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_descriptor_pool.html">DescriptorPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a pool of descriptor objects which is used to allocate descriptors and to store them while they are not safe to delete.  <a href="classtervel_1_1util_1_1memory_1_1rc_1_1_descriptor_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html">PoolElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to hold the memory management information (<a class="el" href="structtervel_1_1util_1_1memory_1_1rc_1_1_pool_element_1_1_header.html" title="All the member variables of PoolElement are stored in a struct so that the left over memory for cache...">Header</a>) and a descriptor object.  <a href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_manager.html">PoolManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manager class for the reference count protected memory pools.  <a href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_read_first_op.html">ReadFirstOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used for placement in the Op Table to complete an operation that failed to complete in a bounded number of steps.  <a href="classtervel_1_1util_1_1memory_1_1rc_1_1_read_first_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38e02080a32927b40a7ac60e1edd4fbf"><td class="memTemplParams" colspan="2">template&lt;typename DescrType , typename... Args &gt; </td></tr>
<tr class="memitem:a38e02080a32927b40a7ac60e1edd4fbf"><td class="memTemplItemLeft" align="right" valign="top">DescrType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a38e02080a32927b40a7ac60e1edd4fbf">get_descriptor</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a38e02080a32927b40a7ac60e1edd4fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a descriptor.  <a href="#a38e02080a32927b40a7ac60e1edd4fbf">More...</a><br /></td></tr>
<tr class="separator:a38e02080a32927b40a7ac60e1edd4fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da2d57615625ad60e4bb151600fdd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a97da2d57615625ad60e4bb151600fdd7">free_descriptor</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr, bool dont_check=false)</td></tr>
<tr class="memdesc:a97da2d57615625ad60e4bb151600fdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once a user is done with a descriptor, they should free it with this method.  <a href="#a97da2d57615625ad60e4bb151600fdd7">More...</a><br /></td></tr>
<tr class="separator:a97da2d57615625ad60e4bb151600fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0694dc5f40b13ca31c143edee459f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#adbd0694dc5f40b13ca31c143edee459f">is_watched</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr)</td></tr>
<tr class="memdesc:adbd0694dc5f40b13ca31c143edee459f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to determine if the passed descriptor is under rc protection.  <a href="#adbd0694dc5f40b13ca31c143edee459f">More...</a><br /></td></tr>
<tr class="separator:adbd0694dc5f40b13ca31c143edee459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4906c41f24991438c68e840c8b833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a1dc4906c41f24991438c68e840c8b833">watch</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr, std::atomic&lt; void * &gt; *address, void *value)</td></tr>
<tr class="memdesc:a1dc4906c41f24991438c68e840c8b833"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to increment the reference count of the passed descriptor object.  <a href="#a1dc4906c41f24991438c68e840c8b833">More...</a><br /></td></tr>
<tr class="separator:a1dc4906c41f24991438c68e840c8b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0964016234e7d046cc64f44c5bc4f856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a0964016234e7d046cc64f44c5bc4f856">unwatch</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr)</td></tr>
<tr class="memdesc:a0964016234e7d046cc64f44c5bc4f856"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to decrement the reference count of the passed descriptor object.  <a href="#a0964016234e7d046cc64f44c5bc4f856">More...</a><br /></td></tr>
<tr class="separator:a0964016234e7d046cc64f44c5bc4f856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b51c075ff02fb2d858097b764827c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a084b51c075ff02fb2d858097b764827c">mark_first</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr)</td></tr>
<tr class="memdesc:a084b51c075ff02fb2d858097b764827c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the passed reference with its least signifcant bit set to 1.  <a href="#a084b51c075ff02fb2d858097b764827c">More...</a><br /></td></tr>
<tr class="separator:a084b51c075ff02fb2d858097b764827c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b15d973adb1f7f052dd96e06f55e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a62b15d973adb1f7f052dd96e06f55e2f">atomic_mark_first</a> (std::atomic&lt; void * &gt; *address)</td></tr>
<tr class="memdesc:a62b15d973adb1f7f052dd96e06f55e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function atomically bit marks the value at address.  <a href="#a62b15d973adb1f7f052dd96e06f55e2f">More...</a><br /></td></tr>
<tr class="separator:a62b15d973adb1f7f052dd96e06f55e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae87a0d05d8fe85f02f711235fc5db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#aaae87a0d05d8fe85f02f711235fc5db5">unmark_first</a> (void *descr)</td></tr>
<tr class="memdesc:aaae87a0d05d8fe85f02f711235fc5db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns an unbitmarked reference.  <a href="#aaae87a0d05d8fe85f02f711235fc5db5">More...</a><br /></td></tr>
<tr class="separator:aaae87a0d05d8fe85f02f711235fc5db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ec07a1f739e0bea27c852b160ba5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#ad86ec07a1f739e0bea27c852b160ba5b">is_descriptor_first</a> (void *descr)</td></tr>
<tr class="memdesc:ad86ec07a1f739e0bea27c852b160ba5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns whether or not the least significant bit holds a bitmark.  <a href="#ad86ec07a1f739e0bea27c852b160ba5b">More...</a><br /></td></tr>
<tr class="separator:ad86ec07a1f739e0bea27c852b160ba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ef9046ee5ae16d7904833a54812309"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a21ef9046ee5ae16d7904833a54812309">remove_descriptor</a> (void *expected, std::atomic&lt; void * &gt; *address)</td></tr>
<tr class="memdesc:a21ef9046ee5ae16d7904833a54812309"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to remove a descriptor object that is conflict with another threads operation.  <a href="#a21ef9046ee5ae16d7904833a54812309">More...</a><br /></td></tr>
<tr class="separator:a21ef9046ee5ae16d7904833a54812309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab30661a8c52aa99a4c59c1afa014e1d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#aab30661a8c52aa99a4c59c1afa014e1d">descriptor_read_first</a> (std::atomic&lt; void * &gt; *address)</td></tr>
<tr class="memdesc:aab30661a8c52aa99a4c59c1afa014e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines the logical value of an address which may have either a RC descriptor or a normal value.  <a href="#aab30661a8c52aa99a4c59c1afa014e1d">More...</a><br /></td></tr>
<tr class="separator:aab30661a8c52aa99a4c59c1afa014e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af7de9780a9cc4ea0db886cbc70ca18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html">PoolElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#a7af7de9780a9cc4ea0db886cbc70ca18">get_elem_from_descriptor</a> (<a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *descr)</td></tr>
<tr class="memdesc:a7af7de9780a9cc4ea0db886cbc70ca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given descriptor was allocated through a <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_descriptor_pool.html" title="Defines a pool of descriptor objects which is used to allocate descriptors and to store them while th...">DescriptorPool</a>, then it has an associated <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html" title="This class is used to hold the memory management information (Header) and a descriptor object...">PoolElement</a> header.  <a href="#a7af7de9780a9cc4ea0db886cbc70ca18">More...</a><br /></td></tr>
<tr class="separator:a7af7de9780a9cc4ea0db886cbc70ca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aebf4eb25eb2e31fc825e8899d97569ac"><td class="memItemLeft" align="right" valign="top">const long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetervel_1_1util_1_1memory_1_1rc.html#aebf4eb25eb2e31fc825e8899d97569ac">DEBUG_EXPECTED_STAMP</a> = 0xDEADBEEF</td></tr>
<tr class="separator:aebf4eb25eb2e31fc825e8899d97569ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a62b15d973adb1f7f052dd96e06f55e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tervel::util::memory::rc::atomic_mark_first </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; void * &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function atomically bit marks the value at address. </p>
<p>This function atomically bit marks the value at address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address to bitmark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab30661a8c52aa99a4c59c1afa014e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* tervel::util::memory::rc::descriptor_read_first </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; void * &gt; *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function determines the logical value of an address which may have either a RC descriptor or a normal value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current logical value </dd></dl>

</div>
</div>
<a class="anchor" id="a97da2d57615625ad60e4bb151600fdd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tervel::util::memory::rc::free_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dont_check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Once a user is done with a descriptor, they should free it with this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>The descriptor to free. </td></tr>
    <tr><td class="paramname">dont_check</td><td>Don't check if the descriptor is being watched before freeing it. Use this flag if you know that no other thread has had access to this descriptor. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use when freeing the descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38e02080a32927b40a7ac60e1edd4fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DescrType , typename... Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DescrType* tervel::util::memory::rc::get_descriptor </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and returns a descriptor. </p>
<p>Arguments are forwarded to the constructor of the given descriptor type. User should call free_descriptor on the returned pointer when they are done with it to avoid memory leaks. </p>

</div>
</div>
<a class="anchor" id="a7af7de9780a9cc4ea0db886cbc70ca18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html">PoolElement</a> * tervel::util::memory::rc::get_elem_from_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the given descriptor was allocated through a <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_descriptor_pool.html" title="Defines a pool of descriptor objects which is used to allocate descriptors and to store them while th...">DescriptorPool</a>, then it has an associated <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html" title="This class is used to hold the memory management information (Header) and a descriptor object...">PoolElement</a> header. </p>
<p>This methods returns that <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html" title="This class is used to hold the memory management information (Header) and a descriptor object...">PoolElement</a>.</p>
<p>Use with caution as Descriptors not allocated from a pool will not have an associated header, and, thus, the returned value will be to some random place in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>The <a class="el" href="classtervel_1_1util_1_1_descriptor.html" title="This defines the Descriptor class, this class is designed to be extend and be used in conjunction wit...">Descriptor</a> pointer allocated through a descriptor pool which thus has an associated <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html" title="This class is used to hold the memory management information (Header) and a descriptor object...">PoolElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated <a class="el" href="classtervel_1_1util_1_1memory_1_1rc_1_1_pool_element.html" title="This class is used to hold the memory management information (Header) and a descriptor object...">PoolElement</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad86ec07a1f739e0bea27c852b160ba5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tervel::util::memory::rc::is_descriptor_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns whether or not the least significant bit holds a bitmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>reference to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not it holds a bitmark </dd></dl>

</div>
</div>
<a class="anchor" id="adbd0694dc5f40b13ca31c143edee459f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tervel::util::memory::rc::is_watched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to determine if the passed descriptor is under rc protection. </p>
<p>Internally calls on_is_watched</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>the descriptor to be checked for rc protection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a084b51c075ff02fb2d858097b764827c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* tervel::util::memory::rc::mark_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the passed reference with its least signifcant bit set to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>the reference to bitmark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bitmarked reference </dd></dl>

</div>
</div>
<a class="anchor" id="a21ef9046ee5ae16d7904833a54812309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* tervel::util::memory::rc::remove_descriptor </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; void * &gt; *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to remove a descriptor object that is conflict with another threads operation. </p>
<p>It first checks the recursive depth before proceeding. Next it protects against the object being reused else where by acquiring either HP or RC watch on the object. Then once it is safe it will call the objects complete function This function must guarantee that after its return the object has been removed It returns the value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expected</td><td>a marked reference to the object </td></tr>
    <tr><td class="paramname">address</td><td>the location expected was read from dereferenced from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current value of the address </dd></dl>

</div>
</div>
<a class="anchor" id="aaae87a0d05d8fe85f02f711235fc5db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a>* tervel::util::memory::rc::unmark_first </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns an unbitmarked reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>reference to remove the bitmark from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unbitmarked reference </dd></dl>

</div>
</div>
<a class="anchor" id="a0964016234e7d046cc64f44c5bc4f856"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tervel::util::memory::rc::unwatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to decrement the reference count of the passed descriptor object. </p>
<p>Then it will call on_unwatch and decrement any related objects necessary Internally calls on_unwatch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>the descriptor which no longer needs rc protection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dc4906c41f24991438c68e840c8b833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tervel::util::memory::rc::watch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtervel_1_1util_1_1_descriptor.html">tervel::util::Descriptor</a> *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; void * &gt; *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to increment the reference count of the passed descriptor object. </p>
<p>If after incrementing the reference count the object is still at the address (indicated by *a == value), it will call on_watch. If that returns true then it will return true. Otherwise it decrements the reference count and returns false Internally calls on_watch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>the descriptor which needs rc protection </td></tr>
    <tr><td class="paramname">address</td><td>address it was dereferenced from </td></tr>
    <tr><td class="paramname">val</td><td>the read value of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully acquired a watch </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aebf4eb25eb2e31fc825e8899d97569ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long tervel::util::memory::rc::DEBUG_EXPECTED_STAMP = 0xDEADBEEF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 4 2015 20:55:22 for Tervel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
